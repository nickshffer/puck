<html>
<head>
    <title>Dashboard</title>
    <meta name="viewport" content="width=210, initial-scale=1">
</head>
<body style="width:210px;height:450px">
<link href="https://espruino.github.io/TinyDash/tinydash.css" rel="stylesheet">
<script src="https://espruino.github.io/TinyDash/tinydash.js"></script>
<script src="https://www.puck-js.com/puck.js"></script>
<script>
    // Called when we get a line of data - updates the light color
    function getArrayWithLimitedLength(length) {
        var array = new Array();

        array.push = function () {
            if (this.length >= length) {
                this.shift();
            }
            return Array.prototype.push.apply(this, arguments);
        }

        return array;

    }

    var acc_x = getArrayWithLimitedLength(50);
    var acc_y = getArrayWithLimitedLength(50);
    var acc_z = getArrayWithLimitedLength(50);

    function onLine(line) {
        try {
            var j = JSON.parse(line);
            elements.light.setValue(j.light * 100);

            acc_x.push(j.acc.x);
            acc_y.push(j.acc.y);
            acc_z.push(j.acc.z);
            console.log(acc_x);

            elements.acc_x.setData(acc_x);
            elements.acc_y.setData(acc_y);
            elements.acc_z.setData(acc_z);

            elements.acc_x_val.setValue(j.acc.x);
            elements.acc_y_val.setValue(j.acc.y);
            elements.acc_z_val.setValue(j.acc.z);
        } catch (e) {
            console.log("Received: ", line);
        }
    }

    var connection;

    function connectDevice() {
        Puck.connect(function (c) {
            if (!c) {
                alert("Couldn't connect!");
                return;
            }
            connection = c;
            // remove modal window
            elements.modal.remove();
            // Handle the data we get back, and call 'onLine'
            // whenever we get a line
            var buf = "";
            connection.on("data", function (d) {
                buf += d;
                var i = buf.indexOf("\n");
                while (i >= 0) {
                    onLine(buf.substr(0, i));
                    buf = buf.substr(i + 1);
                    i = buf.indexOf("\n");
                }
            });
            // First, reset Puck.js
            connection.write("reset();\n", function () {
                // Wait for it to reset itself
                setTimeout(function () {
                    // Now tell it to write data on the current light level to Bluetooth
                    // 10 times a second. Also ensure that when disconnected, Puck.js
                    // resets so the setInterval doesn't keep draining battery.
                    connection.write("setInterval(function(){Bluetooth.println(JSON.stringify({acc:Puck.accel()}));},100);NRF.on('disconnect',function(){Puck.accOn();reset();});\n",
                        function () {
                            console.log("Ready...");
                        });
                }, 1500);
            });
        });

    }

    // Set up the controls we see on the screen
    var elements = {
        heading: TD.label({x: 10, y: 10, width: 190, height: 50, label: "My Dashboard"}),
        light: TD.gauge({x: 10, y: 70, width: 190, height: 220, label: "Light", value: 0, min: 0, max: 100}),
        acc_x_val:TD.value({x:10, y:90, width:190, height:60,label:"X",value:"0"}),
        acc_y_val:TD.value({x:10, y:160, width:190, height:60,label:"Y",value:"0"}),
        acc_z_val:TD.value({x:10, y:230, width:190, height:60,label:"Z",value:"0"}),
        acc_x: TD.graph({x: 210, y: 10, width: 400, height: 180, label: "acc X"}),
        acc_y: TD.graph({x: 210, y: 200, width: 400, height: 180, label: "acc Y"}),
        acc_z: TD.graph({x: 210, y: 390, width: 400, height: 180, label: "acc Z"}),
        modal: TD.modal({x: 10, y: 10, width: 190, height: 430, label: "Click to connect", onchange: connectDevice})
    }
    for (var i in elements)
        document.body.appendChild(elements[i]);
</script>
</body>
</html>
